# Core Concepts

Definitions and structures of key Copilot Sentinel components.

---

## The `.wrapper/` Directory

All Copilot Sentinel files live in `.wrapper/` at your project root:

```
your-project/
├── .wrapper/
│   ├── architecture.md          # [YOU EDIT] Target architecture
│   ├── repo.yaml                # [YOU EDIT] Repo boundaries
│   ├── config.yaml              # [YOU EDIT] LLM settings (optional)
│   │
│   ├── step.yaml                # [AUTO] Current work unit
│   ├── copilot_prompt.txt       # [AUTO] Prompt for AI
│   ├── copilot_output.txt       # [YOU PASTE] AI response
│   │
│   ├── state.json               # [AUTO] Audit log
│   ├── baseline_snapshot.json   # [AUTO] Initial repo scan
│   ├── deviations.yaml          # [AUTO] Architecture violations
│   ├── implementation_plan.yaml # [AUTO] Multi-step plan (optional)
│   └── external_state.json      # [AUTO] Dependency repo states
```

---

## State Files (Auto-Generated)

### `state.json` - Audit Log

**What it is:** Append-only record of all accepted steps.

**Structure:**
```json
{
  "repo": "agent",
  "done_steps": [
    {
      "step_id": "verify-baseline",
      "result": "verification completed",
      "timestamp": "2024-01-15T10:30:00"
    },
    {
      "step_id": "remove-flask-server",
      "result": "implementation completed",
      "timestamp": "2024-01-15T11:45:00"
    }
  ],
  "invariants": [
    "Uses polling for jobs",
    "No HTTP server"
  ],
  "last_verify_status": "PASS",
  "last_verify_step": "remove-flask-server"
}
```

**Key fields:**
- `done_steps` - All accepted steps in chronological order
- `last_verify_status` - "PASS" or "FAIL" (blocks accept if not PASS)
- `last_verify_step` - Most recent verified step ID
- `invariants` - Core principles extracted from architecture

---

### `step.yaml` - Current Work Unit

**What it is:** Defines the work you're doing right now.

**Structure:**
```yaml
step_id: remove-flask-server
type: implementation
goal: |
  Remove Flask HTTP server code, violates no-http-server constraint
allowed_files:
  - src/main.py
  - requirements.txt
forbidden:
  - "Add new HTTP endpoints"
  - "Create new Flask routes"
features:
  - Remove Flask app initialization
  - Remove route handlers (@app.route)
  - Remove Flask from requirements.txt
success_criteria:
  - No Flask imports remain
  - No HTTP server starts on any port
```

**Key fields:**
- `step_id` - Unique identifier
- `type` - "implementation" or "verification"
- `goal` - What you're trying to achieve
- `allowed_files` - **Only these files can be modified** (enforced via git diff)
- `forbidden` - Actions you must not take
- `features` - Checklist of what to implement
- `success_criteria` - How to know you're done

---

### `deviations.yaml` - Architecture Violations

**What it is:** List of ways your code violates `architecture.md`.

**Structure:**
```yaml
deviations:
  - id: http-server-present
    description: "Flask server in main.py violates no-http-server constraint"
    severity: high
    affected_files: 
      - src/main.py
    resolution_step: remove-flask-server
    status: resolved
  
  - id: direct-db-access
    description: "SQLAlchemy in models.py violates no-direct-db constraint"
    severity: high
    affected_files: 
      - src/models/user.py
      - src/models/job.py
    resolution_step: null
    status: open
  
  - id: missing-polling
    description: "No polling mechanism found for job queue"
    severity: medium
    affected_files: []
    resolution_step: null
    status: open
```

**Key fields:**
- `id` - Unique deviation identifier
- `severity` - "high", "medium", or "low"
- `affected_files` - Files containing the violation
- `resolution_step` - Step that fixed it (null if still open)
- `status` - "open" or "resolved"

**Generated by:** LLM during first `wrapper verify` (baseline capture)

---

### `baseline_snapshot.json` - Repository State

**What it is:** Snapshot of your repo when you first ran `wrapper verify`.

**Structure:**
```json
{
  "timestamp": "2024-01-15T10:00:00",
  "branch": "main",
  "commit": "a1b2c3d4",
  "summary": {
    "total_files": 47,
    "total_directories": 12,
    "file_types": {
      ".py": 42,
      ".yaml": 3,
      ".md": 2
    }
  },
  "files": [
    "src/main.py",
    "src/models/user.py",
    "src/utils/helpers.py",
    "..."
  ],
  "directories": [
    "src/",
    "src/models/",
    "src/utils/",
    "..."
  ]
}
```

**Key fields:**
- `summary` - High-level statistics
- `files` - List of all files (excluding `.git`, `node_modules`, `.wrapper`)
- `directories` - List of all directories

**Used for:** Comparing current state to original state (drift detection)

---

### `implementation_plan.yaml` - Strategic Plan (Optional)

**What it is:** Multi-step refactoring plan generated by `wrapper plan init`.

**Structure:**
```yaml
phases:
  - id: phase-1
    name: "Remove HTTP Server"
    steps:
      - step_id: remove-flask-routes
        title: "Remove Flask application"
        features: 
          - "Remove Flask app"
          - "Remove route handlers"
        files_to_modify: 
          - src/main.py
        requirements:
          security: 
            - "Ensure no ports remain open"
        estimated_hours: 2
        completed: false
      
      - step_id: update-dependencies
        title: "Remove Flask from dependencies"
        features: 
          - "Remove Flask from requirements.txt"
        files_to_modify: 
          - requirements.txt
        estimated_hours: 0.5
        completed: false
  
  - id: phase-2
    name: "Add Polling Mechanism"
    steps:
      - step_id: implement-poller
        title: "Implement job polling"
        features:
          - "Create JobPoller class"
          - "Poll every 30 seconds"
        files_to_modify:
          - src/poller.py
        estimated_hours: 4
        completed: false
```

**Key fields:**
- `phases` - High-level groupings
- `steps` - Individual work units
- `features` - What to implement
- `requirements` - Security/performance/cost constraints
- `completed` - Tracking flag

**When exists:** `wrapper propose` reads from plan instead of generating steps dynamically

---

### `external_state.json` - Dependency States (Multi-Repo)

**What it is:** States of other repos this repo depends on.

**Structure:**
```json
{
  "ui": {
    "done_steps": [
      "verify-baseline: verification completed"
    ],
    "high_severity_deviations": [
      {
        "id": "no-polling-endpoint",
        "description": "Missing /api/jobs/poll endpoint",
        "severity": "high",
        "resolved": false
      }
    ],
    "blockers": ["no-polling-endpoint"]
  },
  "auth": {
    "done_steps": [
      "verify-baseline: verification completed",
      "fix-token-validation: implementation completed"
    ],
    "high_severity_deviations": [],
    "blockers": []
  }
}
```

**Key fields:**
- Each key is a repo name
- `blockers` - High-severity unresolved deviations
- `high_severity_deviations` - All high-severity issues

**Generated by:** `wrapper sync-external --from ../other-repo`

---

## Configuration Files (You Edit)

### `architecture.md` - Target Architecture

**What it is:** Natural language description of your ideal system.

**Format:** Markdown (free-form)

**Example:**
```markdown
# Agent Architecture

## Constraints
- NO HTTP endpoints (security requirement)
- NO direct database access (use API layer)
- All jobs MUST timeout after 5 minutes
- Polling interval: 30 seconds maximum

## Components

### JobPoller
- Checks queue every 30 seconds
- Retrieves jobs via API
- No local caching

### Executor
- Runs jobs in isolated containers
- Enforces 5-minute timeout
- Reports results to API

### API Client
- Single point of external communication
- Handles authentication
- Rate limiting: 100 requests/minute
```

**How it's used:** LLM reads this as text to understand your rules

---

### `repo.yaml` - Repository Boundaries

**What it is:** Defines what this repo should and shouldn't do.

**Structure:**
```yaml
repo_name: agent
repo_role: |
  Job execution engine. Polls for jobs and executes them.

must_not:
  - expose inbound HTTP APIs
  - contain UI logic
  - directly access databases
  - implement authentication logic

depends_on:
  - repo: ui
    via: REST API polling endpoints
  - repo: auth
    via: token validation API
```

**Key fields:**
- `repo_name` - Identifier
- `repo_role` - What this repo does
- `must_not` - Forbidden behaviors
- `depends_on` - External dependencies

---

### `config.yaml` - LLM Configuration (Optional)

**What it is:** LLM provider settings.

**Structure:**
```yaml
llm_provider: deepseek  # or 'openai' or 'anthropic'

# API keys (prefer environment variables)
deepseek_api_key: sk-...
openai_api_key: sk-...
anthropic_api_key: sk-...
```

**Note:** Environment variables are preferred over config file.

---

## Guarantees

### Deterministic (Hard) Guarantees

These **cannot be bypassed** - enforced by code, not LLM:

| Guarantee | Enforcement |
|-----------|-------------|
| **File allowlist** | Git diff checked against `allowed_files` - set subtraction |
| **Accept blocking** | Code checks `state.json["last_verify_status"] == "PASS"` |
| **Cross-repo sync** | Reads actual `.wrapper/state.json` from filesystem |
| **Audit log** | Append-only `state.json`, never overwritten |
| **Baseline capture** | `os.walk()` scans actual filesystem |

**How they work:**
- Git is source of truth (can't fake diffs)
- Filesystem reads are direct (no LLM involved)
- Code logic enforces gates (no interpretation)

---

### Soft (LLM-Based) Guarantees

These **can be tricked** - rely on LLM interpretation:

| Guarantee | Enforcement |
|-----------|-------------|
| **Architecture compliance** | LLM reads `architecture.md` and compares to code |
| **Logic verification** | LLM checks if features are correctly implemented |
| **Forbidden patterns** | Keyword search + LLM analysis (e.g., "no HTTP" → searches for `app.get()`) |
| **Deviation detection** | LLM scans codebase and lists violations |
| **Deviation resolution** | LLM determines if step fixed a deviation |

**How they work:**
- LLM reads natural language rules
- LLM analyzes code semantically
- Can be fooled by misleading comments or synonyms

**Example bypass:**
```python
# Forbidden: HTTP server
# Can bypass by using different libraries or misleading LLM with comments
```

---

## Key Concepts

### Step

**What it is:** A single unit of work with defined scope.

**Types:**
- `implementation` - Write code, modify files
- `verification` - Analyze only, no code changes

**Lifecycle:**
1. Proposed (`wrapper propose`)
2. Compiled (`wrapper compile`)
3. Worked on (manually with AI)
4. Verified (`wrapper verify`)
5. Accepted (`wrapper accept`)

---

### Baseline

**What it is:** The first snapshot of your repository.

**Purpose:** Document reality before starting fixes.

**When captured:** First `wrapper verify` in a repo.

**Result:** Always PASS (not enforcement, just documentation)

---

### Deviation

**What it is:** A violation of your `architecture.md` rules.

**Severity levels:**
- `high` - Critical violations (blocks dependencies if cross-repo)
- `medium` - Should fix but not critical
- `low` - Nice-to-have improvements

**Lifecycle:**
1. Detected during baseline capture
2. Listed in `deviations.yaml` (status: open)
3. Targeted by fix steps
4. Resolved when step accepted (status: resolved)

---

### Allowed Files

**What it is:** List of files in `step.yaml` that can be modified.

**Enforcement:** Deterministic - git diff checked via set subtraction.

**Example:**
```yaml
allowed_files:
  - src/main.py
  - requirements.txt
```

**Result:** If you modify `src/utils.py`, verification fails.

---

### Blocking (Multi-Repo)

**What it is:** Dependency repo has high-severity unresolved deviation.

**Result:** `wrapper propose` generates a "BLOCKED" step instead of real work.

**Example:**
```yaml
step_id: blocked-waiting-for-ui
type: blocked
goal: Cannot proceed until ui repo resolves no-polling-endpoint
blocked_by:
  - repo: ui
    deviation: no-polling-endpoint
```

---

## Limitations

### What This Tool Does NOT Do

1. **No code parsing** - No AST analysis, type checking, or linting
2. **No test execution** - Does not run your tests or CI/CD
3. **No formal verification** - LLM checks are guidance, not proofs
4. **No security guarantees** - Can be bypassed if you try
5. **No offline mode** - Requires LLM API access
6. **No multi-language analysis** - LLM-dependent, works best with popular languages

### Known Bypass Vectors

**Forbidden patterns:**
- Use synonyms (e.g., `fetch()` instead of `axios()` if "axios" is forbidden)

**Architecture compliance:**
- Trick LLM with misleading comments
- Use obfuscated code

**Logic verification:**
- Make diff look correct but break at runtime
- Hide bugs in edge cases

**Dependency blocking:**
- Manually edit `external_state.json`
- Skip running `sync-external`

**Important:** This is **workflow discipline**, not security enforcement.

---

## Summary

| File | Purpose | Type |
|------|---------|------|
| `state.json` | Audit trail | Auto-generated |
| `step.yaml` | Current work | Auto-generated |
| `deviations.yaml` | Violations | Auto-generated |
| `baseline_snapshot.json` | Initial state | Auto-generated |
| `implementation_plan.yaml` | Strategic plan | Auto-generated (optional) |
| `external_state.json` | Dependency states | Auto-generated (multi-repo) |
| `architecture.md` | Target rules | You write |
| `repo.yaml` | Boundaries | You write |
| `config.yaml` | LLM settings | You write (optional) |

---

## Next Steps

- **[How It Works](how-it-works.md)** - Understand workflows and processes
- **[Commands](commands.md)** - Learn all available commands
- **[Getting Started](getting-started.md)** - Hands-on tutorial
- **[Examples](examples.md)** - Real-world scenarios
